This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-06T07:08:38.860Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/
  app/
    api/
      completion/
        route.ts
    expenses/
      page.tsx
    incomes/
      page.tsx
    overview/
      page.tsx
    settings/
      page.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    account-form.tsx
    account-list.tsx
    category-configurator.tsx
    expense-ai-converter.tsx
    expense-form.tsx
    expense-list.tsx
    hydration-boundary.tsx
    income-form.tsx
    income-list.tsx
    navigation.tsx
  hooks/
    use-shared-query-params.ts
    use-toast.ts
  lib/
    utils.ts
  stores/
    account-store.ts
    category-store.ts
    expense-store.ts
    income-store.ts
_.gitignore copy
.eslintrc.json
.gitattributes
.gitignore
.prettierignore
components.json
LICENSE
next-env.d.ts
next.config.mjs
package.json
postcss.config.mjs
prettier.config.cjs
README.md
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/app/api/completion/route.ts
================
import { streamText } from 'ai'

import { openai } from '@ai-sdk/openai'

const BASE_PROMPT = `I will paste a list of transactions at the end of the chat.
Please format those transactions as such:
1. Amount should be formatted to be just the number, to 2 decimals, no currency needed
2. Category should be based on the following rules
    - If description includes 'NTUC' referece, category should be 'home'
    - If description includes 'BUS/MRT' referece, category should be 'transport'
    - If description includes 'PRUDENTIAL' referece, category should be 'investment'
    - All others try your best to guess based on the following categories list: home, transport, investment, shopping
3. Date should be formatted to \`yyyy-MM-dd\`
4. Description should be the description from the pasted content without any numeric or \`Singapore SG\` references.

You should return the list in the following format:
\`\`\`
<amount>, <category>, <date>, <title>
\`\`\`
<transactionList>
<TRANSACTION_LIST>
</transactionList>
`

/** Based on the first user and openai messages, generates a title for the conversation */
export async function POST(req: Request) {
  const { prompt }: { prompt: string } = await req.json()

  console.info({ prompt, BASE_PROMPT })

  /** Using plain generate, not streaming data as the whole response is very vast and short */
  const result = await streamText({
    /** Using gpt 4o mini as it is cheaper and yet fast, for limited task like a conversation title */
    model: openai('gpt-4o-mini'),
    prompt: BASE_PROMPT.replace('<TRANSACTION_LIST>', prompt)
  })

  console.info(result)

  return result.toDataStreamResponse()
}

================
File: src/app/expenses/page.tsx
================
'use client'

import React from 'react'

import { ExpenseForm } from '@/components/expense-form'
import { ExpenseList } from '@/components/expense-list'
import { useSharedQueryParams } from '@/hooks/use-shared-query-params'

export default function ExpensesPage() {
  const currentDate = new Date()
  const { selectedYear, setSelectedYear, selectedMonth, setSelectedMonth } = useSharedQueryParams()

  return (
    <>
      <h1 className="text-2xl font-bold mb-4">Expenses</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        <div>
          <ExpenseList
            selectedYear={selectedYear}
            selectedMonth={selectedMonth}
            onYearChange={setSelectedYear}
            onMonthChange={setSelectedMonth}
          />
        </div>
        <div>
          <ExpenseForm selectedYear={selectedYear} selectedMonth={selectedMonth} />
        </div>
      </div>
    </>
  )
}

================
File: src/app/incomes/page.tsx
================
'use client'

import React from 'react'

import { IncomeForm } from '@/components/income-form'
import { IncomeList } from '@/components/income-list'
import { useSharedQueryParams } from '@/hooks/use-shared-query-params'

export default function IncomesPage() {
  const { selectedYear, setSelectedYear, selectedMonth, setSelectedMonth } = useSharedQueryParams()

  return (
    <>
      <h1 className="text-2xl font-bold mb-4">Incomes</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        <div>
          <IncomeList
            selectedYear={selectedYear}
            selectedMonth={selectedMonth}
            onYearChange={setSelectedYear}
            onMonthChange={setSelectedMonth}
          />
        </div>
        <div>
          <IncomeForm selectedYear={selectedYear} selectedMonth={selectedMonth} />
        </div>
      </div>
    </>
  )
}

================
File: src/app/overview/page.tsx
================
'use client'

import React, { useState } from 'react'

import { AccountForm } from '@/components/account-form'
import { AccountList } from '@/components/account-list'
import { Button } from '@/components/ui/button'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { useSharedQueryParams } from '@/hooks/use-shared-query-params'
import { useAccountStore } from '@/stores/account-store'
import { useExpenseStore } from '@/stores/expense-store'
import { useIncomeStore } from '@/stores/income-store'

export default function OverviewPage() {
  const { selectedYear, setSelectedYear, selectedMonth, setSelectedMonth } = useSharedQueryParams()
  const { getAccountBalances } = useAccountStore()
  const { expenses } = useExpenseStore()
  const { incomes } = useIncomeStore()
  const [isAddAccountDialogOpen, setIsAddAccountDialogOpen] = useState(false)

  const currentYear = new Date().getFullYear()
  const years = Array.from({ length: 5 }, (_, i) => currentYear - i)
  const months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
  ]

  const calculateTotalBalance = (year: number, month: number) => {
    return getAccountBalances(year, month).reduce((total, account) => total + account.amount, 0)
  }

  const calculateTotalExpenses = (year: number, month: number) => {
    return expenses
      .filter((expense) => {
        const expenseDate = new Date(expense.date)
        return expenseDate.getFullYear() === year && expenseDate.getMonth() === month
      })
      .reduce((total, expense) => total + expense.amount, 0)
  }

  const calculateTotalIncome = (year: number, month: number) => {
    return incomes
      .filter((income) => {
        const incomeDate = new Date(income.date)
        return incomeDate.getFullYear() === year && incomeDate.getMonth() === month
      })
      .reduce((total, income) => total + income.amount, 0)
  }

  const getPreviousMonthYear = (year: number, month: number) => {
    if (month === 0) {
      return { year: year - 1, month: 11 }
    }
    return { year, month: month - 1 }
  }

  const currentMonthBalance = calculateTotalBalance(selectedYear, selectedMonth)
  const currentMonthExpenses = calculateTotalExpenses(selectedYear, selectedMonth)
  const currentMonthIncome = calculateTotalIncome(selectedYear, selectedMonth)

  const { year: prevYear, month: prevMonth } = getPreviousMonthYear(selectedYear, selectedMonth)
  const previousMonthBalance = calculateTotalBalance(prevYear, prevMonth)

  const expectedAccountsTotal = previousMonthBalance + currentMonthIncome - currentMonthExpenses
  const realAccountsTotal = currentMonthBalance
  const discrepancy = realAccountsTotal - expectedAccountsTotal

  return (
    <div className="space-y-8">
      <h1 className="text-3xl font-bold">Financial Overview</h1>

      <div className="flex space-x-4">
        <Select value={selectedYear.toString()} onValueChange={(value) => setSelectedYear(parseInt(value))}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Select Year" />
          </SelectTrigger>
          <SelectContent>
            {years.map((year) => (
              <SelectItem key={year} value={year.toString()}>
                {year}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>

        <Select value={selectedMonth.toString()} onValueChange={(value) => setSelectedMonth(parseInt(value))}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Select Month" />
          </SelectTrigger>
          <SelectContent>
            {months.map((month, index) => (
              <SelectItem key={index} value={index.toString()}>
                {month}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        <div className="space-y-4">
          <h2 className="text-2xl font-semibold">Summary</h2>
          <ul className="space-y-2">
            <li>Total Account Balances: ${currentMonthBalance.toFixed(2)}</li>
            <li>Total Expenses: ${currentMonthExpenses.toFixed(2)}</li>
            <li>Total Income: ${currentMonthIncome.toFixed(2)}</li>
            <li>Expected Accounts Total: ${expectedAccountsTotal.toFixed(2)}</li>
            <li>Real Accounts Total: ${realAccountsTotal.toFixed(2)}</li>
            <li className={`font-bold ${discrepancy >= 0 ? 'text-green-600' : 'text-red-600'}`}>
              Discrepancy: ${discrepancy.toFixed(2)}
            </li>
          </ul>
        </div>

        <div className="space-y-4">
          <div className="flex justify-between items-center">
            <h2 className="text-2xl font-semibold">Account Balances</h2>
            <Dialog open={isAddAccountDialogOpen} onOpenChange={setIsAddAccountDialogOpen}>
              <DialogTrigger asChild>
                <Button>Add Account</Button>
              </DialogTrigger>
              <DialogContent>
                <DialogHeader>
                  <DialogTitle>Add New Account Balance</DialogTitle>
                </DialogHeader>
                <AccountForm
                  onSubmit={() => setIsAddAccountDialogOpen(false)}
                  selectedYear={selectedYear}
                  selectedMonth={selectedMonth}
                />
              </DialogContent>
            </Dialog>
          </div>
          <AccountList selectedYear={selectedYear} selectedMonth={selectedMonth} />
        </div>
      </div>
    </div>
  )
}

================
File: src/app/settings/page.tsx
================
import React from 'react'

import { CategoryConfigurator } from '@/components/category-configurator'

export default function SettingsPage() {
  return (
    <>
      <h1 className="text-2xl font-bold mb-4">Settings</h1>
      <div className="mt-4">
        <h2 className="text-xl font-semibold mb-4">Category Configuration</h2>
        <CategoryConfigurator />
      </div>
    </>
  )
}

================
File: src/app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

textarea {
  field-sizing: content;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 142.1 76.2% 36.3%;
    --primary-foreground: 355.7 100% 97.3%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 142.1 76.2% 36.3%;
    --radius: 1rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 20 14.3% 4.1%;
    --foreground: 0 0% 95%;
    --card: 24 9.8% 10%;
    --card-foreground: 0 0% 95%;
    --popover: 0 0% 9%;
    --popover-foreground: 0 0% 95%;
    --primary: 142.1 70.6% 45.3%;
    --primary-foreground: 144.9 80.4% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 15%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 85.7% 97.3%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 142.4 71.8% 29.2%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: src/app/layout.tsx
================
import './globals.css'

import type { Metadata } from 'next'
import localFont from 'next/font/local'

import { HydrationBoundary } from '@/components/hydration-boundary'
import { Navigation } from '@/components/navigation'
import { Toaster } from '@/components/ui/toaster'

const geistSans = localFont({
  src: './fonts/GeistVF.woff',
  variable: '--font-geist-sans',
  weight: '100 900'
})
const geistMono = localFont({
  src: './fonts/GeistMonoVF.woff',
  variable: '--font-geist-mono',
  weight: '100 900'
})

export const metadata: Metadata = {
  title: 'Buddy App',
  description: 'Personal finance management app'
}

export default function RootLayout({
  children
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <HydrationBoundary>
          <div className="min-h-screen flex flex-col">
            <Navigation />
            <main className="flex-grow mx-auto p-4 max-w-7xl w-full">{children}</main>
          </div>
          <Toaster />
        </HydrationBoundary>
      </body>
    </html>
  )
}

================
File: src/app/page.tsx
================
'use client'

import React from 'react'

import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table'
import { useSharedQueryParams } from '@/hooks/use-shared-query-params'
import { useCategoryStore } from '@/stores/category-store'
import { useExpenseStore } from '@/stores/expense-store'
import { useIncomeStore } from '@/stores/income-store'

export default function HomePage() {
  const currentDate = new Date()
  const { selectedYear, setSelectedYear, selectedMonth, setSelectedMonth } = useSharedQueryParams()

  const { expenseCategories, incomeCategories } = useCategoryStore()
  const expenses = useExpenseStore((state) => state.expenses)
  const incomes = useIncomeStore((state) => state.incomes)

  const years = Array.from({ length: 5 }, (_, i) => currentDate.getFullYear() - i)
  const months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
  ]

  const calculateCategoryAmount = (
    items: typeof expenses | typeof incomes,
    categoryName: string,
    isAnnual: boolean = false
  ) => {
    return items
      .filter((item) => {
        const itemDate = new Date(item.date)
        return (
          item.category === categoryName &&
          (isAnnual
            ? itemDate.getFullYear() === selectedYear
            : itemDate.getFullYear() === selectedYear && itemDate.getMonth() === selectedMonth)
        )
      })
      .reduce((total, item) => total + item.amount, 0)
  }

  const getRowBackgroundColor = (currentAmount: number, budget: number | undefined) => {
    if (budget === undefined) return 'bg-gray-100'
    const difference = budget - currentAmount
    const percentageDifference = (difference / budget) * 100

    if (percentageDifference > 20) return 'bg-green-100'
    if (percentageDifference >= 0) return 'bg-orange-100'
    return 'bg-red-100'
  }

  const totalMonthlyExpenses = expenses
    .filter((expense) => {
      const expenseDate = new Date(expense.date)
      return expenseDate.getFullYear() === selectedYear && expenseDate.getMonth() === selectedMonth
    })
    .reduce((total, expense) => total + expense.amount, 0)

  const totalMonthlyIncomes = incomes
    .filter((income) => {
      const incomeDate = new Date(income.date)
      return incomeDate.getFullYear() === selectedYear && incomeDate.getMonth() === selectedMonth
    })
    .reduce((total, income) => total + income.amount, 0)

  return (
    <div className="space-y-8">
      <h1 className="text-3xl font-bold">Budget Overview</h1>

      <div className="flex space-x-4">
        <Select value={selectedYear.toString()} onValueChange={(value) => setSelectedYear(parseInt(value))}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Select Year" />
          </SelectTrigger>
          <SelectContent>
            {years.map((year) => (
              <SelectItem key={year} value={year.toString()}>
                {year}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>

        <Select value={selectedMonth.toString()} onValueChange={(value) => setSelectedMonth(parseInt(value))}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Select Month" />
          </SelectTrigger>
          <SelectContent>
            {months.map((month, index) => (
              <SelectItem key={index} value={index.toString()}>
                {month}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-6">
        <h2 className="text-2xl font-semibold">Monthly Overview</h2>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Category</TableHead>
              <TableHead className="text-right">Total</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            <TableRow className="font-medium">
              <TableCell>Total Income</TableCell>
              <TableCell className="text-right">${totalMonthlyIncomes.toFixed(2)}</TableCell>
            </TableRow>
            <TableRow className="font-medium">
              <TableCell>Total Expenses</TableCell>
              <TableCell className="text-right">${totalMonthlyExpenses.toFixed(2)}</TableCell>
            </TableRow>
            <TableRow className="font-medium">
              <TableCell>Net Income</TableCell>
              <TableCell
                className={`text-right ${totalMonthlyIncomes - totalMonthlyExpenses >= 0 ? 'text-green-600' : 'text-red-600'}`}
              >
                ${(totalMonthlyIncomes - totalMonthlyExpenses).toFixed(2)}
              </TableCell>
            </TableRow>
          </TableBody>
        </Table>
      </div>

      <div className="space-y-6">
        <h2 className="text-2xl font-semibold">Expense Categories</h2>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Category</TableHead>
              <TableHead className="text-right">Current Expense</TableHead>
              <TableHead className="text-right">Monthly Budget</TableHead>
              <TableHead className="text-right">Annual Budget</TableHead>
              <TableHead>Overview</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {expenseCategories.map((category) => {
              const currentMonthlyExpense = calculateCategoryAmount(expenses, category.name)
              const currentAnnualExpense = calculateCategoryAmount(expenses, category.name, true)
              const monthlyDifference =
                category.maxBudget !== undefined ? category.maxBudget - currentMonthlyExpense : undefined
              const annualDifference =
                category.maxAnnualBudget !== undefined ? category.maxAnnualBudget - currentAnnualExpense : undefined
              const rowColor = getRowBackgroundColor(currentMonthlyExpense, category.maxBudget)

              return (
                <TableRow key={category.name} className={rowColor}>
                  <TableCell className="font-medium">{category.name}</TableCell>
                  <TableCell className="text-right">${currentMonthlyExpense.toFixed(2)}</TableCell>
                  <TableCell className="text-right">
                    {category.maxBudget !== undefined ? `$${category.maxBudget.toFixed(2)}` : 'N/A'}
                  </TableCell>
                  <TableCell className="text-right">
                    {category.maxAnnualBudget !== undefined ? `$${category.maxAnnualBudget.toFixed(2)}` : 'N/A'}
                  </TableCell>
                  <TableCell>
                    {monthlyDifference !== undefined && (
                      <span className={monthlyDifference >= 0 ? 'text-green-600' : 'text-red-600'}>
                        Monthly: {monthlyDifference >= 0 ? 'Under by: ' : 'Over by: '}$
                        {Math.abs(monthlyDifference).toFixed(2)}
                      </span>
                    )}
                    {annualDifference !== undefined && (
                      <span className={`block ${annualDifference >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                        Annual: {annualDifference >= 0 ? 'Under by: ' : 'Over by: '}$
                        {Math.abs(annualDifference).toFixed(2)}
                      </span>
                    )}
                  </TableCell>
                </TableRow>
              )
            })}
          </TableBody>
        </Table>
      </div>

      <div className="space-y-6">
        <h2 className="text-2xl font-semibold">Income Categories</h2>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Category</TableHead>
              <TableHead className="text-right">Current Income</TableHead>
              <TableHead className="text-right">Target Amount</TableHead>
              <TableHead>Overview</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {incomeCategories.map((category) => {
              const currentMonthlyIncome = calculateCategoryAmount(incomes, category.title)
              const difference =
                category.targetAmount !== undefined ? category.targetAmount - currentMonthlyIncome : undefined
              const rowColor = getRowBackgroundColor(currentMonthlyIncome, category.targetAmount)

              return (
                <TableRow key={category.title} className={rowColor}>
                  <TableCell className="font-medium">{category.title}</TableCell>
                  <TableCell className="text-right">${currentMonthlyIncome.toFixed(2)}</TableCell>
                  <TableCell className="text-right">
                    {category.targetAmount !== undefined ? `$${category.targetAmount.toFixed(2)}` : 'N/A'}
                  </TableCell>
                  <TableCell>
                    {difference !== undefined && (
                      <span className={difference >= 0 ? 'text-red-600' : 'text-green-600'}>
                        {difference >= 0 ? 'Under by: ' : 'Over by: '}${Math.abs(difference).toFixed(2)}
                      </span>
                    )}
                  </TableCell>
                </TableRow>
              )
            })}
          </TableBody>
        </Table>
      </div>
    </div>
  )
}

================
File: src/components/account-form.tsx
================
'use client'

import React, { useState } from 'react'
import { useForm } from 'react-hook-form'

import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { useToast } from '@/hooks/use-toast'
import { AccountBalance, useAccountStore } from '@/stores/account-store'

interface AccountFormProps {
  initialData?: AccountBalance
  onSubmit: () => void
  selectedYear: number
  selectedMonth: number
}

export const AccountForm: React.FC<AccountFormProps> = ({ initialData, onSubmit, selectedYear, selectedMonth }) => {
  const { addAccountBalance, updateAccountBalance } = useAccountStore()
  const { toast } = useToast()
  const [isSubmitting, setIsSubmitting] = useState(false)

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset
  } = useForm<Omit<AccountBalance, 'id'>>({
    defaultValues: initialData || {
      title: '',
      amount: 0,
      year: selectedYear,
      month: selectedMonth
    }
  })

  const onSubmitForm = async (data: Omit<AccountBalance, 'id'>) => {
    setIsSubmitting(true)
    try {
      if (initialData) {
        updateAccountBalance(initialData.id, data)
        toast({
          title: 'Account balance updated',
          description: `Updated balance for ${data.title}`
        })
      } else {
        addAccountBalance(data)
        toast({
          title: 'Account balance added',
          description: `Added new balance for ${data.title}`
        })
      }
      reset()
      onSubmit()
    } catch (error) {
      toast({
        title: 'Error',
        description: 'An error occurred while saving the account balance.',
        variant: 'destructive'
      })
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmitForm)} className="space-y-4">
      <div>
        <Input {...register('title', { required: 'Title is required' })} placeholder="Account Title" />
        {errors.title && <p className="text-red-500 text-sm mt-1">{errors.title.message}</p>}
      </div>
      <div>
        <Input
          type="number"
          step="0.01"
          {...register('amount', { required: 'Amount is required', valueAsNumber: true })}
          placeholder="Balance Amount"
        />
        {errors.amount && <p className="text-red-500 text-sm mt-1">{errors.amount.message}</p>}
      </div>
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Saving...' : initialData ? 'Update Balance' : 'Add Balance'}
      </Button>
    </form>
  )
}

================
File: src/components/account-list.tsx
================
'use client'

import { Edit2, Trash2 } from 'lucide-react'
import React, { useState } from 'react'

import { AccountForm } from '@/components/account-form'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle
} from '@/components/ui/alert-dialog'
import { Button } from '@/components/ui/button'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog'
import { useToast } from '@/hooks/use-toast'
import { AccountBalance, useAccountStore } from '@/stores/account-store'

interface AccountListProps {
  selectedYear: number
  selectedMonth: number
}

export const AccountList: React.FC<AccountListProps> = ({ selectedYear, selectedMonth }) => {
  const { getAccountBalances, removeAccountBalance } = useAccountStore()
  const { toast } = useToast()
  const [editingAccount, setEditingAccount] = useState<AccountBalance | null>(null)
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false)
  const [accountToDelete, setAccountToDelete] = useState<AccountBalance | null>(null)

  const accountBalances = getAccountBalances(selectedYear, selectedMonth)

  const handleEdit = (account: AccountBalance) => {
    setEditingAccount(account)
  }

  const handleDelete = (account: AccountBalance) => {
    setAccountToDelete(account)
    setIsDeleteDialogOpen(true)
  }

  const confirmDelete = () => {
    if (accountToDelete) {
      removeAccountBalance(accountToDelete.id)
      toast({
        title: 'Account balance deleted',
        description: `Deleted balance for ${accountToDelete.title}`
      })
      setIsDeleteDialogOpen(false)
      setAccountToDelete(null)
    }
  }

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold">Account Balances</h2>
      {accountBalances.length === 0 ? (
        <p>No account balances for this month.</p>
      ) : (
        <ul className="space-y-2">
          {accountBalances.map((account) => (
            <li key={account.id} className="flex justify-between items-center bg-gray-100 p-2 rounded">
              <div>
                <span className="font-semibold">{account.title}</span>: ${account.amount.toFixed(2)}
              </div>
              <div className="space-x-2">
                <Button variant="outline" size="sm" onClick={() => handleEdit(account)}>
                  <Edit2 className="h-4 w-4" />
                </Button>
                <Button variant="outline" size="sm" onClick={() => handleDelete(account)}>
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            </li>
          ))}
        </ul>
      )}

      <Dialog open={editingAccount !== null} onOpenChange={(open) => !open && setEditingAccount(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Edit Account Balance</DialogTitle>
          </DialogHeader>
          {editingAccount && (
            <AccountForm
              initialData={editingAccount}
              onSubmit={() => setEditingAccount(null)}
              selectedYear={selectedYear}
              selectedMonth={selectedMonth}
            />
          )}
        </DialogContent>
      </Dialog>

      <AlertDialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the account balance.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={confirmDelete}>Delete</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  )
}

================
File: src/components/category-configurator.tsx
================
'use client'

import React, { useEffect, useState } from 'react'

import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { useToast } from '@/hooks/use-toast'
import { ExpenseCategory, IncomeCategory, useCategoryStore } from '@/stores/category-store'

export const CategoryConfigurator: React.FC = () => {
  const { expenseCategories, incomeCategories, setExpenseCategories, setIncomeCategories, isHydrated } =
    useCategoryStore()
  const [expenseTextareaContent, setExpenseTextareaContent] = useState('')
  const [incomeTextareaContent, setIncomeTextareaContent] = useState('')
  const { toast } = useToast()

  useEffect(() => {
    if (isHydrated) {
      // Convert expense categories to textarea content
      const expenseContent = expenseCategories
        .map((category) => `${category.name},${category.maxBudget || ''},${category.maxAnnualBudget || ''}`)
        .join('\n')
      setExpenseTextareaContent(expenseContent)

      // Convert income categories to textarea content
      const incomeContent = incomeCategories
        .map((category) => `${category.title},${category.targetAmount || ''}`)
        .join('\n')
      setIncomeTextareaContent(incomeContent)
    }
  }, [expenseCategories, incomeCategories, isHydrated])

  const handleSaveExpenses = () => {
    try {
      const newExpenseCategories: ExpenseCategory[] = expenseTextareaContent
        .split('\n')
        .filter((line) => line.trim() !== '')
        .map((line) => {
          const [name, maxBudget, maxAnnualBudget] = line.split(',')
          if (!name) {
            throw new Error(`Invalid format: ${line}`)
          }
          return {
            name: name.trim(),
            maxBudget: maxBudget ? parseFloat(maxBudget.trim()) : undefined,
            maxAnnualBudget: maxAnnualBudget ? parseFloat(maxAnnualBudget.trim()) : undefined
          }
        })

      // Check for unique names
      const names = new Set<string>()
      newExpenseCategories.forEach((category) => {
        if (names.has(category.name)) {
          throw new Error(`Duplicate expense category name: ${category.name}`)
        }
        names.add(category.name)
      })

      setExpenseCategories(newExpenseCategories)
      toast({
        title: 'Expense categories saved successfully',
        description: `Saved ${newExpenseCategories.length} expense categories.`
      })
    } catch (error) {
      toast({
        title: 'Error saving expense categories',
        description: error instanceof Error ? error.message : 'Unknown error',
        variant: 'destructive'
      })
    }
  }

  const handleSaveIncomes = () => {
    try {
      const newIncomeCategories: IncomeCategory[] = incomeTextareaContent
        .split('\n')
        .filter((line) => line.trim() !== '')
        .map((line) => {
          const [title, targetAmount] = line.split(',')
          if (!title) {
            throw new Error(`Invalid format: ${line}`)
          }
          return {
            title: title.trim(),
            targetAmount: targetAmount ? parseFloat(targetAmount.trim()) : undefined
          }
        })

      // Check for unique titles
      const titles = new Set<string>()
      newIncomeCategories.forEach((category) => {
        if (titles.has(category.title)) {
          throw new Error(`Duplicate income category title: ${category.title}`)
        }
        titles.add(category.title)
      })

      setIncomeCategories(newIncomeCategories)
      toast({
        title: 'Income categories saved successfully',
        description: `Saved ${newIncomeCategories.length} income categories.`
      })
    } catch (error) {
      toast({
        title: 'Error saving income categories',
        description: error instanceof Error ? error.message : 'Unknown error',
        variant: 'destructive'
      })
    }
  }

  if (!isHydrated) {
    return <div>Loading...</div>
  }

  return (
    <div className="space-y-8">
      <div className="space-y-4">
        <h2 className="text-xl font-semibold">Expense Categories</h2>
        <Textarea
          value={expenseTextareaContent}
          onChange={(e) => setExpenseTextareaContent(e.target.value)}
          placeholder="Enter expense categories (name,maxBudget,maxAnnualBudget)"
          rows={10}
          className="font-mono"
        />
        <Button onClick={handleSaveExpenses}>Save Expense Categories</Button>
      </div>

      <div className="space-y-4">
        <h2 className="text-xl font-semibold">Income Categories</h2>
        <Textarea
          value={incomeTextareaContent}
          onChange={(e) => setIncomeTextareaContent(e.target.value)}
          placeholder="Enter income categories (title,targetAmount)"
          rows={10}
          className="font-mono"
        />
        <Button onClick={handleSaveIncomes}>Save Income Categories</Button>
      </div>
    </div>
  )
}

================
File: src/components/expense-ai-converter.tsx
================
'use client'

import { useCompletion } from 'ai/react'
import { Loader2 } from 'lucide-react'

import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { useToast } from '@/hooks/use-toast'

interface Props {
  handleTextareaAddExpenses: () => void
  setTextareaContent: (value: string) => void
  textareaContent: string
}

export const ExpenseAiConverter = ({ handleTextareaAddExpenses, setTextareaContent, textareaContent }: Props) => {
  const { toast } = useToast()

  const { completion, input, handleInputChange, handleSubmit, isLoading, error } = useCompletion({
    api: '/api/completion',
    onFinish: (prompt: string, completion: string) => {
      setTextareaContent(completion.replaceAll('```', ''))
    },
    onError: (error: Error) => {
      if (error) {
        toast({
          title: 'Error',
          description: error.message,
          variant: 'destructive'
        })
      }
    }
  })

  return (
    <>
      <form onSubmit={handleSubmit} className="space-y-4">
        <Textarea
          name="prompt"
          value={input}
          onChange={handleInputChange}
          placeholder="Enter your expense details here..."
          className="min-h-[100px]"
        />
        <Button type="submit" disabled={isLoading} className="w-full">
          {isLoading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Converting...
            </>
          ) : (
            'Convert'
          )}
        </Button>
      </form>
      {error && <div className="text-red-500 mt-4">Error: {error.message}</div>}
      {completion ? (
        <>
          <div className="space-y-4">
            <Textarea
              value={textareaContent}
              onChange={(e) => setTextareaContent(e.target.value)}
              placeholder="Enter expenses (amount,category,date,description)"
              rows={10}
              className="font-mono"
            />
            <Button onClick={handleTextareaAddExpenses}>Add Expenses</Button>
          </div>
        </>
      ) : null}
    </>
  )
}

================
File: src/components/expense-form.tsx
================
import { TrashIcon } from 'lucide-react'
import React, { useState } from 'react'

import { Button } from '@/components/ui/button'
import { DatePicker } from '@/components/ui/date-picker'
import { Input } from '@/components/ui/input'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Textarea } from '@/components/ui/textarea'
import { useToast } from '@/hooks/use-toast'
import { useCategoryStore } from '@/stores/category-store'
import { useExpenseStore } from '@/stores/expense-store'

import { ExpenseAiConverter } from './expense-ai-converter'

interface ExpenseFormProps {
  selectedYear: number
  selectedMonth: number
}

interface TableExpense {
  amount: string
  category: string
  date: Date
  description: string
}

export const ExpenseForm: React.FC<ExpenseFormProps> = ({ selectedYear, selectedMonth }) => {
  const [textareaContent, setTextareaContent] = useState('')
  const [tableExpenses, setTableExpenses] = useState<TableExpense[]>([
    { amount: '', category: '', date: getDefaultDate(selectedYear, selectedMonth), description: '' }
  ])
  const [rowsToAdd, setRowsToAdd] = useState(1)
  const { addExpense } = useExpenseStore()
  const expenseCategories = useCategoryStore((state) => state.expenseCategories)
  const { toast } = useToast()

  function getDefaultDate(year: number, month: number): Date {
    const currentDate = new Date()
    if (currentDate.getFullYear() === year && currentDate.getMonth() === month) {
      return currentDate
    }
    return new Date(year, month, 15)
  }

  const handleTextareaAddExpenses = () => {
    const lines = textareaContent.split('\n').filter((line) => line.trim() !== '')
    const defaultDate = getDefaultDate(selectedYear, selectedMonth)
    let hasError = false

    const newExpenses = lines.map((line, index) => {
      const [amount, category = 'unknown', date = defaultDate.toISOString().split('T')[0], description = ''] = line
        .split(',')
        .map((s) => s.trim())

      if (!amount || isNaN(Number(amount))) {
        toast({
          title: 'Invalid expense',
          description: `Invalid amount in line ${index + 1}: ${line}`,
          variant: 'destructive'
        })
        hasError = true
        return null
      }

      const expenseDate = new Date(date)
      if (expenseDate.getFullYear() !== selectedYear || expenseDate.getMonth() !== selectedMonth) {
        toast({
          title: 'Invalid date',
          description: `Expense in line ${index + 1} is not for the selected month and year`,
          variant: 'destructive'
        })
        hasError = true
        return null
      }

      const validCategory = expenseCategories.some((c) => c.name === category) ? category : 'unknown'

      return {
        amount: Number(amount),
        category: validCategory,
        date: date,
        description
      }
    })

    if (!hasError) {
      newExpenses.forEach((expense) => {
        if (expense) addExpense(expense)
      })
      setTextareaContent('')
      toast({
        title: 'Expenses added',
        description: `Added ${newExpenses.length} expense(s)`
      })
    }
  }

  const handleTableAddExpenses = () => {
    let hasError = false
    const newExpenses = tableExpenses.map((expense, index) => {
      if (!expense.amount || isNaN(Number(expense.amount)) || Number(expense.amount) <= 0) {
        toast({
          title: 'Invalid expense',
          description: `Invalid amount in row ${index + 1}`,
          variant: 'destructive'
        })
        hasError = true
        return null
      }

      const expenseDate = new Date(expense.date)
      if (expenseDate.getFullYear() !== selectedYear || expenseDate.getMonth() !== selectedMonth) {
        toast({
          title: 'Invalid date',
          description: `Expense in row ${index + 1} is not for the selected month and year`,
          variant: 'destructive'
        })
        hasError = true
        return null
      }

      return {
        amount: Number(expense.amount),
        category: expense.category || 'unknown',
        date: expense.date.toISOString().split('T')[0],
        description: expense.description
      }
    })

    if (!hasError) {
      newExpenses.forEach((expense) => {
        if (expense) addExpense(expense)
      })
      setTableExpenses([
        { amount: '', category: '', date: getDefaultDate(selectedYear, selectedMonth), description: '' }
      ])
      toast({
        title: 'Expenses added',
        description: `Added ${newExpenses.length} expense(s)`
      })
    }
  }

  const handleTableInputChange = (index: number, field: keyof TableExpense, value: string | Date) => {
    const updatedExpenses = [...tableExpenses]
    updatedExpenses[index] = { ...updatedExpenses[index], [field]: value }
    setTableExpenses(updatedExpenses)
  }

  const handleTableKeyDown = (event: React.KeyboardEvent<HTMLInputElement>, index: number) => {
    if (event.key === 'Enter') {
      event.preventDefault()
      setTableExpenses([
        ...tableExpenses,
        { amount: '', category: '', date: getDefaultDate(selectedYear, selectedMonth), description: '' }
      ])
    }
  }

  const addRows = () => {
    const newRows = Array(rowsToAdd)
      .fill(null)
      .map(() => ({ amount: '', category: '', date: getDefaultDate(selectedYear, selectedMonth), description: '' }))
    setTableExpenses([...tableExpenses, ...newRows])
  }

  const deleteRow = (index: number) => {
    const updatedExpenses = tableExpenses.filter((_, i) => i !== index)
    setTableExpenses(updatedExpenses)
  }

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold">
        Add Expenses for{' '}
        {new Date(selectedYear, selectedMonth).toLocaleString('default', { month: 'long', year: 'numeric' })}
      </h2>
      <Tabs defaultValue="table-form">
        <TabsList>
          <TabsTrigger value="table-form">Table Entry</TabsTrigger>
          <TabsTrigger value="textarea-form">Bulk Entry</TabsTrigger>
          <TabsTrigger value="ai-converter">AI converter</TabsTrigger>
        </TabsList>
        <TabsContent value="table-form">
          <div className="space-y-4">
            <div className="overflow-x-auto">
              <table className="w-full border-collapse border border-gray-200">
                <thead>
                  <tr>
                    <th className="border border-gray-200 p-2 w-[110px]">Amount</th>
                    <th className="border border-gray-200 p-2 w-[130px]">Category</th>
                    <th className="border border-gray-200 p-2 w-[130px]">Date</th>
                    <th className="border border-gray-200 p-2 w-[150px]">Description</th>
                    <th className="border border-gray-200 p-2 w-[50px]"></th>
                  </tr>
                </thead>
                <tbody>
                  {tableExpenses.map((expense, index) => (
                    <tr key={index}>
                      <td className="border border-gray-200 p-1">
                        <Input
                          type="number"
                          value={expense.amount}
                          onChange={(e) => handleTableInputChange(index, 'amount', e.target.value)}
                          onKeyDown={(e) => handleTableKeyDown(e, index)}
                          step="0.01"
                          min="0"
                          required
                          className="w-full h-full rounded-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none py-2"
                        />
                      </td>
                      <td className="border border-gray-200 p-1">
                        <Select
                          value={expense.category}
                          onValueChange={(value) => handleTableInputChange(index, 'category', value)}
                        >
                          <SelectTrigger className="w-full h-full rounded-none">
                            <SelectValue placeholder="Select category" />
                          </SelectTrigger>
                          <SelectContent>
                            {expenseCategories.map((category) => (
                              <SelectItem key={category.name} value={category.name}>
                                {category.name}
                              </SelectItem>
                            ))}
                          </SelectContent>
                        </Select>
                      </td>
                      <td className="border border-gray-200 p-1">
                        <DatePicker
                          date={expense.date}
                          onDateChange={(date) => handleTableInputChange(index, 'date', date!)}
                          className="w-full h-full rounded-none"
                        />
                      </td>
                      <td className="border border-gray-200 p-1">
                        <Input
                          type="text"
                          value={expense.description}
                          onChange={(e) => handleTableInputChange(index, 'description', e.target.value)}
                          onKeyDown={(e) => handleTableKeyDown(e, index)}
                          className="w-full h-full rounded-none py-2"
                        />
                      </td>
                      <td className="border border-gray-200 p-1">
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => deleteRow(index)}
                          className="w-full h-full rounded-none"
                        >
                          <TrashIcon className="h-7 w-4" />
                        </Button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
            <div className="flex items-center space-x-2">
              <Input
                type="number"
                value={rowsToAdd}
                onChange={(e) => setRowsToAdd(Number(e.target.value))}
                min="1"
                className="w-20 [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
              />
              <Button onClick={addRows}>Add Rows</Button>
            </div>
            <Button onClick={handleTableAddExpenses}>Save Expenses</Button>
          </div>
        </TabsContent>
        <TabsContent value="textarea-form">
          <div className="space-y-4">
            <Textarea
              value={textareaContent}
              onChange={(e) => setTextareaContent(e.target.value)}
              placeholder="Enter expenses (amount,category,date,description)"
              rows={10}
              className="font-mono w-full"
            />
            <Button onClick={handleTextareaAddExpenses}>Add Expenses</Button>
          </div>
        </TabsContent>
        <TabsContent value="ai-converter">
          <ExpenseAiConverter
            handleTextareaAddExpenses={handleTextareaAddExpenses}
            setTextareaContent={setTextareaContent}
            textareaContent={textareaContent}
          />
        </TabsContent>
      </Tabs>
    </div>
  )
}

================
File: src/components/expense-list.tsx
================
import React, { useEffect } from 'react'

import { Button } from '@/components/ui/button'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { useExpenseStore } from '@/stores/expense-store'

interface ExpenseListProps {
  selectedYear: number
  selectedMonth: number
  onYearChange: (year: number) => void
  onMonthChange: (year: number) => void
}

export const ExpenseList: React.FC<ExpenseListProps> = ({
  selectedMonth,
  selectedYear,
  onYearChange,
  onMonthChange
}) => {
  const { expenses, removeExpense } = useExpenseStore()

  const currentYear = new Date().getFullYear()

  const years = [currentYear, currentYear - 1, currentYear - 2]
  const months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
  ]

  const filteredExpenses = expenses.filter((expense) => {
    const expenseDate = new Date(expense.date)
    return expenseDate.getFullYear() === selectedYear && expenseDate.getMonth() === selectedMonth
  })

  return (
    <div className="space-y-4">
      <div className="flex space-x-4">
        <Select value={selectedYear.toString()} onValueChange={(value) => onYearChange(Number(value))}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Select Year" />
          </SelectTrigger>
          <SelectContent>
            {years.map((year) => (
              <SelectItem key={year} value={year.toString()}>
                {year}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <Select value={selectedMonth.toString()} onValueChange={(value) => onMonthChange(Number(value))}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Select Month" />
          </SelectTrigger>
          <SelectContent>
            {months.map((month, index) => (
              <SelectItem key={index} value={index.toString()}>
                {month}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
      <h2 className="text-xl font-semibold">
        Expenses for {months[selectedMonth]} {selectedYear}
      </h2>
      {filteredExpenses.length === 0 ? (
        <p>No expenses for this month.</p>
      ) : (
        <ul className="space-y-2">
          {filteredExpenses.map((expense) => (
            <li key={expense.id} className="flex justify-between items-center bg-gray-100 p-2 rounded">
              <div>
                <span className="font-semibold">{expense.date}</span>: {expense.amount.toFixed(2)} -{' '}
                {expense.description}
                <span className="ml-2 text-sm text-gray-600">({expense.category})</span>
              </div>
              <Button variant="destructive" size="sm" onClick={() => removeExpense(expense.id)}>
                Delete
              </Button>
            </li>
          ))}
        </ul>
      )}
    </div>
  )
}

================
File: src/components/hydration-boundary.tsx
================
'use client'

import React, { useEffect, useState } from 'react'

import { useCategoryStore } from '@/stores/category-store'
import { useExpenseStore } from '@/stores/expense-store'
import { useIncomeStore } from '@/stores/income-store'

export function HydrationBoundary({ children }: { children: React.ReactNode }) {
  const [isHydrated, setIsHydrated] = useState(false)
  const categoryHydrated = useCategoryStore((state) => state.isHydrated)
  const expenseHydrated = useExpenseStore((state) => state.isHydrated)
  const incomeHydrated = useIncomeStore((state) => state.isHydrated)

  useEffect(() => {
    if (categoryHydrated && expenseHydrated && incomeHydrated) {
      setIsHydrated(true)
    }
  }, [categoryHydrated, expenseHydrated, incomeHydrated])

  if (!isHydrated) {
    return <div>Loading...</div>
  }

  return <>{children}</>
}

================
File: src/components/income-form.tsx
================
'use client'

import { TrashIcon } from 'lucide-react'
import React, { useState } from 'react'

import { Button } from '@/components/ui/button'
import { DatePicker } from '@/components/ui/date-picker'
import { Input } from '@/components/ui/input'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { useToast } from '@/hooks/use-toast'
import { useCategoryStore } from '@/stores/category-store'
import { useIncomeStore } from '@/stores/income-store'

interface IncomeFormProps {
  selectedYear: number
  selectedMonth: number
}

interface TableIncome {
  amount: string
  category: string
  date: Date
  description: string
}

export const IncomeForm: React.FC<IncomeFormProps> = ({ selectedYear, selectedMonth }) => {
  const [tableIncomes, setTableIncomes] = useState<TableIncome[]>([
    { amount: '', category: '', date: getDefaultDate(selectedYear, selectedMonth), description: '' }
  ])
  const [rowsToAdd, setRowsToAdd] = useState(1)
  const { addIncome } = useIncomeStore()
  const { incomeCategories } = useCategoryStore()
  const { toast } = useToast()

  function getDefaultDate(year: number, month: number): Date {
    const currentDate = new Date()
    if (currentDate.getFullYear() === year && currentDate.getMonth() === month) {
      return currentDate
    }
    return new Date(year, month, 15)
  }

  const handleTableAddIncomes = () => {
    let hasError = false
    const newIncomes = tableIncomes.map((income, index) => {
      if (!income.amount || isNaN(Number(income.amount)) || Number(income.amount) <= 0) {
        toast({
          title: 'Invalid income',
          description: `Invalid amount in row ${index + 1}`,
          variant: 'destructive'
        })
        hasError = true
        return null
      }

      const incomeDate = new Date(income.date)
      if (incomeDate.getFullYear() !== selectedYear || incomeDate.getMonth() !== selectedMonth) {
        toast({
          title: 'Invalid date',
          description: `Income in row ${index + 1} is not for the selected month and year`,
          variant: 'destructive'
        })
        hasError = true
        return null
      }

      return {
        amount: Number(income.amount),
        category: income.category || 'uncategorized',
        date: income.date.toISOString().split('T')[0],
        description: income.description
      }
    })

    if (!hasError) {
      newIncomes.forEach((income) => {
        if (income) addIncome(income)
      })
      setTableIncomes([
        { amount: '', category: '', date: getDefaultDate(selectedYear, selectedMonth), description: '' }
      ])
      toast({
        title: 'Incomes added',
        description: `Added ${newIncomes.length} income(s)`
      })
    }
  }

  const handleTableInputChange = (index: number, field: keyof TableIncome, value: string | Date) => {
    const updatedIncomes = [...tableIncomes]
    updatedIncomes[index] = { ...updatedIncomes[index], [field]: value }
    setTableIncomes(updatedIncomes)
  }

  const handleTableKeyDown = (event: React.KeyboardEvent<HTMLInputElement>, index: number) => {
    if (event.key === 'Enter') {
      event.preventDefault()
      setTableIncomes([
        ...tableIncomes,
        { amount: '', category: '', date: getDefaultDate(selectedYear, selectedMonth), description: '' }
      ])
    }
  }

  const addRows = () => {
    const newRows = Array(rowsToAdd)
      .fill(null)
      .map(() => ({ amount: '', category: '', date: getDefaultDate(selectedYear, selectedMonth), description: '' }))
    setTableIncomes([...tableIncomes, ...newRows])
  }

  const deleteRow = (index: number) => {
    const updatedIncomes = tableIncomes.filter((_, i) => i !== index)
    setTableIncomes(updatedIncomes)
  }

  return (
    <div className="space-y-4">
      <h2 className="text-xl font-semibold">
        Add Incomes for{' '}
        {new Date(selectedYear, selectedMonth).toLocaleString('default', { month: 'long', year: 'numeric' })}
      </h2>
      <div className="space-y-4">
        <div className="overflow-x-auto">
          <table className="w-full border-collapse border border-gray-200">
            <thead>
              <tr>
                <th className="border border-gray-200 p-2 w-[110px]">Amount</th>
                <th className="border border-gray-200 p-2 w-[130px]">Category</th>
                <th className="border border-gray-200 p-2 w-[130px]">Date</th>
                <th className="border border-gray-200 p-2 w-[150px]">Description</th>
                <th className="border border-gray-200 p-2 w-[50px]"></th>
              </tr>
            </thead>
            <tbody>
              {tableIncomes.map((income, index) => (
                <tr key={index}>
                  <td className="border border-gray-200 p-1">
                    <Input
                      type="number"
                      value={income.amount}
                      onChange={(e) => handleTableInputChange(index, 'amount', e.target.value)}
                      onKeyDown={(e) => handleTableKeyDown(e, index)}
                      step="0.01"
                      min="0"
                      required
                      className="w-full h-full rounded-none [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none py-2"
                    />
                  </td>
                  <td className="border border-gray-200 p-1">
                    <Select
                      value={income.category}
                      onValueChange={(value) => handleTableInputChange(index, 'category', value)}
                    >
                      <SelectTrigger className="w-full h-full rounded-none">
                        <SelectValue placeholder="Select category" />
                      </SelectTrigger>
                      <SelectContent>
                        {incomeCategories.map((category) => (
                          <SelectItem key={category.title} value={category.title}>
                            {category.title}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </td>
                  <td className="border border-gray-200 p-1">
                    <DatePicker
                      date={income.date}
                      onDateChange={(date) => handleTableInputChange(index, 'date', date!)}
                      className="w-full h-full rounded-none"
                    />
                  </td>
                  <td className="border border-gray-200 p-1">
                    <Input
                      type="text"
                      value={income.description}
                      onChange={(e) => handleTableInputChange(index, 'description', e.target.value)}
                      onKeyDown={(e) => handleTableKeyDown(e, index)}
                      className="w-full h-full rounded-none py-2"
                    />
                  </td>
                  <td className="border border-gray-200 p-1">
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => deleteRow(index)}
                      className="w-full h-full rounded-none"
                    >
                      <TrashIcon className="h-7 w-4" />
                    </Button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
        <div className="flex items-center space-x-2">
          <Input
            type="number"
            value={rowsToAdd}
            onChange={(e) => setRowsToAdd(Number(e.target.value))}
            min="1"
            className="w-20 [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
          />
          <Button onClick={addRows}>Add Rows</Button>
        </div>
        <Button onClick={handleTableAddIncomes}>Save Incomes</Button>
      </div>
    </div>
  )
}

================
File: src/components/income-list.tsx
================
'use client'

import React from 'react'

import { Button } from '@/components/ui/button'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { useIncomeStore } from '@/stores/income-store'

interface IncomeListProps {
  selectedYear: number
  selectedMonth: number
  onYearChange: (year: number) => void
  onMonthChange: (month: number) => void
}

export const IncomeList: React.FC<IncomeListProps> = ({ selectedMonth, selectedYear, onYearChange, onMonthChange }) => {
  const { incomes, removeIncome } = useIncomeStore()

  const currentYear = new Date().getFullYear()

  const years = [currentYear, currentYear - 1, currentYear - 2]
  const months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
  ]

  const filteredIncomes = incomes.filter((income) => {
    const incomeDate = new Date(income.date)
    return incomeDate.getFullYear() === selectedYear && incomeDate.getMonth() === selectedMonth
  })

  return (
    <div className="space-y-4">
      <div className="flex space-x-4">
        <Select value={selectedYear.toString()} onValueChange={(value) => onYearChange(Number(value))}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Select Year" />
          </SelectTrigger>
          <SelectContent>
            {years.map((year) => (
              <SelectItem key={year} value={year.toString()}>
                {year}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <Select value={selectedMonth.toString()} onValueChange={(value) => onMonthChange(Number(value))}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Select Month" />
          </SelectTrigger>
          <SelectContent>
            {months.map((month, index) => (
              <SelectItem key={index} value={index.toString()}>
                {month}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
      <h2 className="text-xl font-semibold">
        Incomes for {months[selectedMonth]} {selectedYear}
      </h2>
      {filteredIncomes.length === 0 ? (
        <p>No incomes for this month.</p>
      ) : (
        <ul className="space-y-2">
          {filteredIncomes.map((income) => (
            <li key={income.id} className="flex justify-between items-center bg-gray-100 p-2 rounded">
              <div>
                <span className="font-semibold">{income.date}</span>: ${income.amount.toFixed(2)} - {income.description}
                <span className="ml-2 text-sm text-gray-600">({income.category})</span>
              </div>
              <Button variant="destructive" size="sm" onClick={() => removeIncome(income.id)}>
                Delete
              </Button>
            </li>
          ))}
        </ul>
      )}
    </div>
  )
}

================
File: src/components/navigation.tsx
================
'use client'

import Link from 'next/link'

import { useSharedQueryParams } from '@/hooks/use-shared-query-params'

const navItems = [
  { href: '/', label: 'Home' },
  { href: '/expenses', label: 'Expenses' },
  { href: '/incomes', label: 'Incomes' },
  { href: '/overview', label: 'Overview' },
  { href: '/settings', label: 'Settings' }
]

export const Navigation = () => {
  const { selectedYear, selectedMonth } = useSharedQueryParams()

  return (
    <nav className="bg-gray-800 text-white p-4">
      <ul className="flex space-x-4">
        {navItems.map((item) => (
          <li key={item.href}>
            <Link
              href={{
                pathname: item.href,
                query: { month: selectedMonth, year: selectedYear }
              }}
              className="hover:underline"
            >
              {item.label}
            </Link>
          </li>
        ))}
      </ul>
    </nav>
  )
}

================
File: src/hooks/use-shared-query-params.ts
================
'use client'

import { parseAsInteger, useQueryState } from 'nuqs'

export function useSharedQueryParams() {
  const currentDate = new Date()

  const [selectedYear, setSelectedYear] = useQueryState('year', parseAsInteger.withDefault(currentDate.getFullYear()))
  const [selectedMonth, setSelectedMonth] = useQueryState('month', parseAsInteger.withDefault(currentDate.getMonth()))

  return {
    selectedYear,
    setSelectedYear,
    selectedMonth,
    setSelectedMonth
  }
}

================
File: src/hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: src/stores/account-store.ts
================
import { create } from 'zustand'
import { createJSONStorage, persist } from 'zustand/middleware'

export interface AccountBalance {
  id: string
  title: string
  amount: number
  year: number
  month: number
}

interface AccountStore {
  accountBalances: AccountBalance[]
  isHydrated: boolean
  addAccountBalance: (accountBalance: Omit<AccountBalance, 'id'>) => void
  updateAccountBalance: (id: string, updatedBalance: Partial<AccountBalance>) => void
  removeAccountBalance: (id: string) => void
  getAccountBalances: (year: number, month: number) => AccountBalance[]
  setHydrated: () => void
}

export const useAccountStore = create<AccountStore>()(
  persist(
    (set, get) => ({
      accountBalances: [],
      isHydrated: false,
      addAccountBalance: (accountBalance) =>
        set((state) => ({
          accountBalances: [...state.accountBalances, { ...accountBalance, id: crypto.randomUUID() }]
        })),
      updateAccountBalance: (id, updatedBalance) =>
        set((state) => ({
          accountBalances: state.accountBalances.map((balance) =>
            balance.id === id ? { ...balance, ...updatedBalance } : balance
          )
        })),
      removeAccountBalance: (id) =>
        set((state) => ({
          accountBalances: state.accountBalances.filter((balance) => balance.id !== id)
        })),
      getAccountBalances: (year, month) => {
        const state = get()
        return state.accountBalances.filter((balance) => balance.year === year && balance.month === month)
      },
      setHydrated: () => set({ isHydrated: true })
    }),
    {
      name: 'account-store',
      storage: createJSONStorage(() => localStorage),
      onRehydrateStorage: () => (state) => {
        state?.setHydrated()
      }
    }
  )
)

================
File: src/stores/category-store.ts
================
import { create } from 'zustand'
import { createJSONStorage, persist } from 'zustand/middleware'

export interface ExpenseCategory {
  name: string
  maxBudget?: number
  maxAnnualBudget?: number
}

export interface IncomeCategory {
  title: string
  targetAmount?: number
}

interface CategoryStore {
  expenseCategories: ExpenseCategory[]
  incomeCategories: IncomeCategory[]
  isHydrated: boolean
  setExpenseCategories: (categories: ExpenseCategory[]) => void
  setIncomeCategories: (categories: IncomeCategory[]) => void
  addExpenseCategory: (category: ExpenseCategory) => void
  addIncomeCategory: (category: IncomeCategory) => void
  removeExpenseCategory: (name: string) => void
  removeIncomeCategory: (title: string) => void
  updateExpenseCategory: (name: string, updatedCategory: ExpenseCategory) => void
  updateIncomeCategory: (title: string, updatedCategory: IncomeCategory) => void
  setHydrated: () => void
}

export const useCategoryStore = create<CategoryStore>()(
  persist(
    (set) => ({
      expenseCategories: [],
      incomeCategories: [],
      isHydrated: false,
      setExpenseCategories: (categories) => set({ expenseCategories: categories }),
      setIncomeCategories: (categories) => set({ incomeCategories: categories }),
      addExpenseCategory: (category) =>
        set((state) => ({
          expenseCategories: [...state.expenseCategories, category]
        })),
      addIncomeCategory: (category) =>
        set((state) => ({
          incomeCategories: [...state.incomeCategories, category]
        })),
      removeExpenseCategory: (name) =>
        set((state) => ({
          expenseCategories: state.expenseCategories.filter((c) => c.name !== name)
        })),
      removeIncomeCategory: (title) =>
        set((state) => ({
          incomeCategories: state.incomeCategories.filter((c) => c.title !== title)
        })),
      updateExpenseCategory: (name, updatedCategory) =>
        set((state) => ({
          expenseCategories: state.expenseCategories.map((c) => (c.name === name ? updatedCategory : c))
        })),
      updateIncomeCategory: (title, updatedCategory) =>
        set((state) => ({
          incomeCategories: state.incomeCategories.map((c) => (c.title === title ? updatedCategory : c))
        })),
      setHydrated: () => set({ isHydrated: true })
    }),
    {
      name: 'category-store',
      storage: createJSONStorage(() => localStorage),
      onRehydrateStorage: () => (state) => {
        state?.setHydrated()
      }
    }
  )
)

================
File: src/stores/expense-store.ts
================
import { create } from 'zustand'
import { createJSONStorage, persist } from 'zustand/middleware'

export interface Expense {
  id: string
  date: string
  amount: number
  description: string
  category: string
}

interface ExpenseStore {
  expenses: Expense[]
  isHydrated: boolean
  addExpense: (expense: Omit<Expense, 'id'>) => void
  removeExpense: (id: string) => void
  setHydrated: () => void
}

export const useExpenseStore = create<ExpenseStore>()(
  persist(
    (set) => ({
      expenses: [],
      isHydrated: false,
      addExpense: (expense) =>
        set((state) => ({
          expenses: [...state.expenses, { ...expense, id: crypto.randomUUID() }]
        })),
      removeExpense: (id) =>
        set((state) => ({
          expenses: state.expenses.filter((e) => e.id !== id)
        })),
      setHydrated: () => set({ isHydrated: true })
    }),
    {
      name: 'expense-store',
      storage: createJSONStorage(() => localStorage),
      onRehydrateStorage: () => (state) => {
        state?.setHydrated()
      }
    }
  )
)

================
File: src/stores/income-store.ts
================
import { create } from 'zustand'
import { createJSONStorage, persist } from 'zustand/middleware'

export interface Income {
  id: string
  date: string
  amount: number
  description: string
  category: string
}

interface IncomeStore {
  incomes: Income[]
  isHydrated: boolean
  addIncome: (income: Omit<Income, 'id'>) => void
  removeIncome: (id: string) => void
  setHydrated: () => void
}

export const useIncomeStore = create<IncomeStore>()(
  persist(
    (set) => ({
      incomes: [],
      isHydrated: false,
      addIncome: (income) =>
        set((state) => ({
          incomes: [...state.incomes, { ...income, id: crypto.randomUUID() }]
        })),
      removeIncome: (id) =>
        set((state) => ({
          incomes: state.incomes.filter((i) => i.id !== id)
        })),
      setHydrated: () => set({ isHydrated: true })
    }),
    {
      name: 'income-store',
      storage: createJSONStorage(() => localStorage),
      onRehydrateStorage: () => (state) => {
        state?.setHydrated()
      }
    }
  )
)

================
File: _.gitignore copy
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: .eslintrc.json
================
{
  "rules": {
    "react/jsx-filename-extension": "off",
    "react/prop-types": "off",
    "typescript-eslint/no-explicit-any": "off"
  },
  "parser": "@typescript-eslint/parser",
  "extends": [
    "plugin:@typescript-eslint/recommended",
    "next/core-web-vitals",
    "next/typescript",
    "plugin:prettier/recommended"
  ]
}

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: .prettierignore
================
# Ignore artifacts:
build
coverage
node_modules
.next

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "stone",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: LICENSE
================
MIT License

Copyright (c) 2024 Alex Radulescu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: next-env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

================
File: package.json
================
{
  "name": "buddy",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "pack": "repopack --ignore './src/components/ui/*'"
  },
  "dependencies": {
    "@ai-sdk/openai": "^0.0.66",
    "@ai-sdk/react": "^0.0.62",
    "@hookform/resolvers": "^3.9.0",
    "@phosphor-icons/react": "^2.1.7",
    "@radix-ui/react-accordion": "^1.2.1",
    "@radix-ui/react-alert-dialog": "^1.1.2",
    "@radix-ui/react-aspect-ratio": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-collapsible": "^1.1.1",
    "@radix-ui/react-context-menu": "^2.2.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-hover-card": "^1.1.2",
    "@radix-ui/react-icons": "^1.3.0",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-menubar": "^1.1.2",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-radio-group": "^1.2.1",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slider": "^1.2.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-toggle": "^1.1.0",
    "@radix-ui/react-toggle-group": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@uiw/react-markdown-preview": "^5.1.3",
    "ai": "^3.4.9",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "input-otp": "^1.2.4",
    "lucide-react": "^0.447.0",
    "next": "14.2.14",
    "next-themes": "^0.3.0",
    "nuqs": "^1.19.3",
    "openai": "^4.67.1",
    "react": "^18",
    "react-day-picker": "8.10.1",
    "react-dom": "^18",
    "react-hook-form": "^7.53.0",
    "react-resizable-panels": "^2.1.4",
    "recharts": "^2.12.7",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.3",
    "tailwindcss-animate": "^1.0.7",
    "usehooks-ts": "^3.1.0",
    "vaul": "^1.0.0",
    "zod": "^3.23.8",
    "zustand": "^5.0.0-rc.2"
  },
  "devDependencies": {
    "@ianvs/prettier-plugin-sort-imports": "^4.3.1",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@typescript-eslint/eslint-plugin": "^8.8.0",
    "@typescript-eslint/parser": "^8.8.0",
    "eslint": "^9.12.0",
    "eslint-config-next": "14.2.14",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.2.1",
    "postcss": "^8",
    "prettier": "^3.3.3",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: prettier.config.cjs
================
/** @type {import('prettier').Config} */
module.exports = {
  printWidth: 120,
  tabWidth: 2,
  useTabs: false,
  semi: false,
  singleQuote: true,
  trailingComma: 'none',
  bracketSpacing: true,
  jsxBracketSameLine: false,
  endOfLine: 'lf',
  plugins: ['@ianvs/prettier-plugin-sort-imports'],
  importOrder: [
    '^react$',
    '^next$',
    '^remix$',
    '<THIRD_PARTY_MODULES>',
    '^(@api|@assets|@ui|src|app|@/hooks|@/components)(/.*)$',
    '^(?!.*[.]css$)[./].*$',
    '.css$'
  ],

  importOrderSeparation: true,
  importOrderSortSpecifiers: true,
  importOrderBuiltinModulesToTop: true,
  importOrderParserPlugins: ['typescript', 'jsx', 'decorators-legacy'],
  importOrderMergeDuplicateImports: true,
  importOrderCombineTypeAndValueImports: true
}

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## TODO

- [] Fix edge cases
- [] Improve performance
- [] Maybe move to Dexie.js
- [] Flag if expenses seem to be the same
- [] Add incomes
- [] Add current account values
- [] Add monthly report with categories report + total
- [] Flag if there are discrepancies between expencted total minus real total
- [] Test the AI converter with DBS and UOB setups
- [] Add links for DBS and UOB
- [] Add categories with annual budgets
- [] Add categories with no budget
- [] Add annual report + 3, 6, 9, and annualised calculations
- [] Add export and import functionality in case things break for backup
- [] Add main overview/dashboard
- [] Sync to the cloud
- [] Add authentication
- [] Make it prettier

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
